#!/usr/bin/env python3

import argparse
import glob
import logging
import os
import pathlib
import subprocess
import sys
import json
import tempfile


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('filename')
    parser.add_argument('--loglevel',
                        default='warning',
                        help='Provide logging level. Example --loglevel debug, default=warning',
                        choices=['info', 'warning', 'debug', 'error'])
    parser.add_argument('--cpu-dep-chain',
                        default='',
                        help='Comma-separated CPU dependency chain. Can be omitted if top-level dts from board directory is provided')
    parser.add_argument('--zephyr-path',
                        default='zephyrproject',
                        help='Path to the Zephyr RTOS main directory')
    parser.add_argument('--arch',
                        default='',
                        help='Name of the board\'s architecture')
    parser.add_argument('--board',
                        default='',
                        help='Zephyr platform/board name')
    parser.add_argument('--output',
                        default='output.repl',
                        help='Output filename')
    parser.add_argument('--base-dts',
                        default='',
                        help='Path to the top-level dts file. Can be omitted if CPU dependency chain is provided')

    args = parser.parse_args()

    logging.basicConfig(level=args.loglevel.upper())
    return args


def dump(obj):
    for attr in dir(obj):
        print("obj.%s = %r" % (attr, getattr(obj, attr)))


def get_cpu_dep_chain(arch, dts_filename, zephyr_path, chain):
    next_include = ''
    if os.path.exists(dts_filename):
        with open(dts_filename) as f:
            dts_file = f.readlines()

        for l in dts_file:
            if next_include == '' and l.startswith('#include'):
                _, next_include = l.split()
                local = not (next_include.startswith('<') and next_include.endswith('>'))
                next_include = next_include.strip(' "<>')
                name, extension = os.path.splitext(next_include)

                # omit header files
                if extension.strip('.') == 'h':
                    next_include = ''
                    continue

                if local:
                    dtsi_filename = f'{os.path.dirname(dts_filename)}/{next_include}'
                    name = '!' + name
                else:
                    dtsi_filename = f'{zephyr_path}/dts/{arch}/{next_include}'

                return get_cpu_dep_chain(arch, dtsi_filename, zephyr_path, chain+[name])
    return chain


def get_uart(dts_filename):
    uart = ''
    if os.path.exists(dts_filename):
        with open(dts_filename, "r") as dts_file:
            for l in dts_file.readlines():
                if 'zephyr,shell-uart' in l:
                    uart = l[l.index('&')+1:l.index(';')].strip()
                    return uart


def setup(zephyr_path):
    sys.path.append(f'{zephyr_path}/zephyr/scripts/dts')

    try:
        from gen_defines import setup_edtlib_logging
    except ModuleNotFoundError:
        print(f'Could not find Zephyr RTOS sources. Is the path {zephyr_path} valid?')
        exit(1)

    setup_edtlib_logging()
    dirs = glob.glob(f'{zephyr_path}/zephyr/dts/bindings/**')
    return dirs


def get_edt(filename, binding_dirs, zephyr_path):
    sys.path.append(f'{zephyr_path}/zephyr/scripts/dts/python-devicetree/src')
    from devicetree import edtlib

    with open(filename) as f:
        dts_file = f.readlines()
        dts_file = filter(lambda x: 'pinctrl-0;' not in x, dts_file)
        dts_file = ''.join(dts_file)

    with tempfile.NamedTemporaryFile(mode='w', encoding='utf-8') as f:
        f.write(dts_file)
        f.flush()

        try:
            edt = edtlib.EDT(f.name, binding_dirs,
                             # Suppress this warning if it's suppressed in dtc
                             warn_reg_unit_address_mismatch=True,
                             default_prop_types=True,
                             infer_binding_for_paths=["/zephyr,user"])
            return edt
        except (edtlib.EDTError, edtlib.DTError) as e:
            logging.error(f"devicetree error: {e}")
            return None


def generate(args):
    edt = get_edt(args.filename, setup(args.zephyr_path), args.zephyr_path)
    if edt is None:
        return ''

    models_path = f'{pathlib.Path(__file__).parent.resolve()}/models.json'
    with open(models_path) as f:
        models = json.load(f)

    repl = [f'// autogenerated']
    nodes = sorted(edt.nodes, key=lambda x: x.compats[0] if len(x.compats) > 0 else "")

    # get mcu compat name
    mcu = next(filter(lambda x: 'cpu' in x.name and len(x.compats), nodes)).compats[0]

    for node in nodes:
        # filter out nodes without compat strings
        if len(node.compats) == 0:
            logging.info(f'Node {node.name} has no compat string. Skipping...')
            continue
        
        # filter out nodes without a sysbus address
        if len(node.name.split('@')) < 2:
            logging.info(f'Node {node.name} has no sysbus address. Skipping...')
            continue

        # filter out nodes without a matching Renode model
        if node.compats[0] not in models:
            logging.info(f'Node {node.name} does not have a matching Renode model. Skipping...')
            continue

        # not sure why this is needed. We need to investigate the RCC->RTC dependency.
        if 'status' in node.props and node.props['status'].val == 'disabled' and node.name[0:3] != "rtc":
            logging.info(f'Node {node.name} disabled. Skipping...')
            continue

        # get model name and addr
        name, addr = node.name.split('@')
        if len(node.labels) > 0:
            name = node.labels[0].lower().replace("_", "")

        if name == 'cpu':
            name += addr

        # decide which Renode model to use
        compat = node.compats[0]
        model = models[compat]

        # this hack is needed for stm32f072b_disco, as needs UART.STM32F7_USART
        # model to work properly while using the same compat strings as boards
        # which require UART.STM32_UART model
        if compat == "st,stm32-usart" and mcu in ("arm,cortex-m0", "arm,cortex-m7", "arm,cortex-m33"):
            compat = "st,stm32-lpuart"
            model = models[compat]

        # this hack is needed for nucleo_l552ze_q_ns; we don't want to
        # instantiate some models with some cpus
        if compat == "st,stm32-rcc" and mcu == "arm,cortex-m33":
            continue

        address = ''
        if not name.startswith('cpu'):
            parent_node = node.parent
            addr_offset = '0'
            if parent_node is not None and 'peripheral' in parent_node.name:
                _, addr_offset = parent_node.name.split('@')

            addr = hex(int(addr, 16) + int(addr_offset, 16))[2:]
            address = f'0x{addr.upper()}'
            if name == 'nvic':
                # weird mismatch, need to investigate, manually patching for now
                address = address[0:-3] + '0' + address[-2:]

            if any(map(lambda x: x in compat, ['stm32', 'silabs,gecko', 'gaisler,irqmp', 'gaisler,gptimer', 'gaisler,apbuart'])):
                start, size = list(map(lambda x: hex(x), node.props['reg'].val))
                address = f'<{start}, +{size}>'

        repl.append(f'{name}: {model} @ sysbus {address}')
        indent = []

        # additional parameters for peripherals
        if compat == "nordic,nrf-uarte":
            indent.append('easyDMA: true')
        if compat == "st,stm32-timers":
            indent.append('frequency: 10000000')
            indent.append('initialLimit: 0xFFFFFFFF')
        if compat.startswith("st,stm32") and compat.endswith("rcc"):
            indent.append('rtcPeripheral: rtc')
        if compat == "st,stm32-lpuart":
            indent.append('frequency: 200000000')
        if compat.startswith('litex,timer'):
            indent.append('frequency: 100000000')
        if compat == 'ns16550':
            indent.append('wideRegisters: true')
        if compat == 'st,stm32-watchdog':
            indent.append('frequency: 32000')
        if compat == 'microsemi,coreuart':
            indent.append('clockFrequency: 66000000')

        # additional parameters for CPUs
        if compat.startswith('arm,cortex-m'):
            cpu = compat.split(',')[1]
            if cpu == 'cortex-m33f':
                cpu = cpu[:-1]
            indent.append(f'cpuType: "{cpu}"')
            indent.append('nvic: nvic')
        if compat.startswith('sifive,rocket'):
            indent.append('cpuType: "rv32imac"')
            indent.append('privilegeArchitecture: PrivilegeArchitecture.Priv1_10')
            indent.append('timeProvider: clint')
        if compat.startswith('microsemi,miv'):
            indent.append('cpuType: "rv32imac"')
            indent.append('privilegeArchitecture: PrivilegeArchitecture.Priv1_09')
            indent.append('timeProvider: clint')
        if compat == 'gaisler,leon3':
            indent.append('cpuType: "leon3"')
        if compat.startswith('starfive,rocket'):
            indent.append('cpuType: "rv64gc"')
            indent.append(f'hartId: {node.name.split("@")[1]}')
            indent.append('privilegeArchitecture: PrivilegeArchitecture.Priv1_10')
            indent.append('timeProvider: clint')

        # additional parameters for IRQ ctrls
        if compat.endswith('nvic'):
            indent.append('-> cpu0@0')
        if compat == 'gaisler,irqmp':
            indent.append('0 -> cpu0@0 | cpu0@1 | cpu0@2')

        # for some reason the only compat string that VexRiscv has is "riscv"
        # check the board compat string and if doesn't match, remove last entry
        if compat == 'riscv':
            if node.parent.parent.compats[0] == 'litex,vexriscv':
                indent.append('cpuType: "rv32imac"')
            else:
                repl.pop()

        # common routine for interrupt providers
        if any(map (lambda x: compat.startswith(x), ['riscv,clint', 'sifive,plic'])):
            irqs = {}
            for i, n in enumerate(node.interrupts):
                ctrl_name = ''.join(n.controller.parent.name.split('@'))
                irqs[ctrl_name] = list(map(lambda x: str(x), irqs.setdefault(ctrl_name, []) + [i] + list(n.data.values())))
            for cpu, irq in irqs.items():
                indent.append(f'[{",".join(irq[::2])}] -> {cpu}@[{",".join(irq[1::2])}]')

        if model.startswith('Timers'):
            if 'cc-num' in node.props:
                indent.append(f'numberOfEvents: {str(node.props["cc-num"].val)}')
        if model.startswith('Memory'):
            if 'reg' in node.props:
                indent.append(f'size: {hex(node.props["reg"].val[-1])}')

        if 'interrupts' in node.props:
            # decide which IRQ destination to use in Renode model
            if any(map (lambda x: mcu.startswith(x), ['sifive', 'starfive'])):
                irq_dest = 'plic'
            elif mcu.startswith('riscv'):  # this is for LiteX!
                irq_dest = 'cpu0'
            elif mcu.startswith('gaisler'):
                irq_dest = 'irqmp'
            else:
                irq_dest = 'nvic'

            # decide which IRQ names to use in Renode model
            if compat == 'st,stm32-rtc':
                irq_names = ['AlarmIRQ']
            elif compat in ['nxp,kinetis-lpuart', 'nxp,kinetis-uart', 'silabs,gecko-leuart', 'sifive,uart0']:
                irq_names = ['IRQ']
            elif compat in ['silabs,gecko-uart', 'silabs,gecko-usart']:
                irq_names = ['ReceiveIRQ', 'TransmitIRQ']
            elif compat in ['gaisler,gptimer']:
                irq_names = ['0']
            else:
                irq_names = ['']

            # assign IRQ signals
            for name, irq in zip(irq_names, node.props['interrupts'].val[::2]):
                indent.append(f'{name}->{irq_dest}@{irq}')

        repl.extend(map(lambda x: f'    {x}', indent))
        repl.append('')

    # soc overlay
    overlay_path = f'{pathlib.Path(__file__).parent.resolve()}/overlay'
    for cpu in map(lambda x: x.split("/")[-1], args.cpu_dep_chain.split(",")[::-1]):
        overlay = f'{overlay_path}/{cpu}.repl'
        if os.path.exists(overlay):
            repl.append('')
            with open(overlay) as f:
                repl.extend(map(lambda x: x.rstrip(), f.readlines()))

    # board overlay
    if len(args.board) == 0 or args.board is None:
        name, _ = os.path.splitext(os.path.basename(args.filename))
    else:
        name = args.board
    overlay = f'{overlay_path}/{name}.repl'
    if os.path.exists(overlay):
        with open(overlay) as f:
            repl.extend(map(lambda x: x.rstrip(), f.readlines()))

    return '\n'.join(repl)


def main():
    args = parse_args()
    if len(args.cpu_dep_chain) == 0:
        args.cpu_dep_chain = ','.join(get_cpu_dep_chain(args.arch, args.base_dts, args.zephyr_path, []))
    with open(args.output, 'w') as f:
        f.write(generate(args))


if __name__ == "__main__":
    main()
